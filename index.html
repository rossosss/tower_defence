<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Игра от 3-го лица с циклом дня и ночи</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            overscroll-behavior-y: contain;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            display:block;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px #000000;
        }
        #timer-container {
            position: absolute;
            top: 10px;
            right: 20px;
            color: white;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px #000000;
            background-color: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            border-radius: 10px;
            text-align: center;
        }
        .modal-content h2 { margin-top: 0; }
        .modal-content button {
            background-color: #4CAF50;
            color: white;
            padding: 14px 20px;
            margin: 8px;
            border: none;
            cursor: pointer;
            width: 40%;
            border-radius: 5px;
            font-size: 16px;
        }
        .modal-content button:hover { opacity: 0.8; }
        .modal-content button.cancel { background-color: #f44336; }
        #focus-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 2000;
        }
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">Используйте WASD для передвижения. Найдите желтый чекпоинт.</div>
    <div id="focus-overlay">Кликните, чтобы играть</div>
    <div id="timer-container">
        <span id="timer-label"></span>
        <span id="timer-value"></span>
    </div>
    <div id="itemModal" class="modal-overlay">
        <div class="modal-content">
            <h2>Выберите предмет для размещения</h2>
            <button id="addCubeBtn">Куб</button>
            <button id="addSphereBtn">Сфера</button>
            <button id="addConeBtn">Конус</button>
            <button id="cancelBtn" class="cancel">Отмена</button>
        </div>
    </div>
    <div id="joystick-zone"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        // === ИНИЦИАЛИЗАЦИЯ ===
        let gameState = 'inactive';
        const scene = new THREE.Scene();
        const mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const orthoCamera = new THREE.OrthographicCamera(window.innerWidth / -50, window.innerWidth / 50, window.innerHeight / 50, window.innerHeight / -50, 1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const focusOverlay = document.getElementById('focus-overlay');
        const infoElement = document.getElementById('info');
        const timerLabel = document.getElementById('timer-label');
        const timerValue = document.getElementById('timer-value');

        // === ПАРАМЕТРЫ ЦИКЛА ДНЯ И НОЧИ ===
        const DAY_DURATION = 60;
        const NIGHT_DURATION = 40;
        const TOTAL_CYCLE_DURATION = DAY_DURATION + NIGHT_DURATION;
        const dayColor = new THREE.Color(0x87ceeb);
        const nightColor = new THREE.Color(0x000033);
        let nightCubes = [];
        let isNight = false;
        let gameTime = 0;

        // === СВЕТ ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(20, 40, 30);
        scene.add(directionalLight);

        // === ОБЪЕКТЫ СЦЕНЫ ===
        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0xff4500 }));
        player.position.y = 0.5;
        scene.add(player);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshStandardMaterial({ color: 0x228b22, side: THREE.DoubleSide }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        const gridHelper = new THREE.GridHelper(50, 50);
        scene.add(gridHelper);

        const checkpoint = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
        checkpoint.position.set(10, 0.1, 10);
        scene.add(checkpoint);

        function createNightObjects() {
            const nightCubeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8A2BE2, 
                emissive: 0x4B0082,
                emissiveIntensity: 0.5
            });
            for (let i = 0; i < 4; i++) {
                const cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), nightCubeMaterial);
                cube.position.set((Math.random() - 0.5) * 40, 1, (Math.random() - 0.5) * 40);
                cube.visible = false;
                nightCubes.push(cube);
                scene.add(cube);
            }
        }
        createNightObjects();

        // === УПРАВЛЕНИЕ И ВРЕМЯ ===
        const clock = new THREE.Clock();
        let keysPressed = {};
        const moveSpeed = 5;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let previewObject = null;
        const isTouchDevice = 'ontouchstart' in window;

        // === УПРАВЛЕНИЕ КАМЕРОЙ ===
        const cameraTarget = new THREE.Vector3();
        const spherical = new THREE.Spherical(10, Math.PI / 3, Math.PI / 4);
        let isDragging = false;
        let isPanning = false;
        let isPinching = false;
        let initialPinchDistance = 0;
        let previousPointerPosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;
        
        // === ДЖОЙСТИК ===
        let joystick = null;
        let joystickVector = new THREE.Vector2();
        if (isTouchDevice) {
            infoElement.innerText = "Используйте джойстик и тач для управления";
            const joystickZone = document.getElementById('joystick-zone');
            joystickZone.style.display = 'block';
            joystick = nipplejs.create({
                zone: joystickZone,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 150
            });
            joystick.on('move', (evt, data) => joystickVector.set(data.vector.x, data.vector.y));
            joystick.on('end', () => joystickVector.set(0, 0));
        }

        // === ЛОГИКА ИГРЫ ===
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function checkCheckpoint() {
            if (gameState !== 'playing') return;
            if (player.position.distanceTo(checkpoint.position) < 2) {
                gameState = 'modal';
                document.getElementById('itemModal').style.display = 'flex';
            }
        }

        function closeModal() {
            document.getElementById('itemModal').style.display = 'none';
            gameState = 'playing';
            if (player.position.distanceTo(checkpoint.position) < 2.1) {
                const direction = new THREE.Vector3().subVectors(player.position, checkpoint.position).normalize();
                player.position.add(direction.multiplyScalar(0.5));
            }
        }

        function startPlacingMode(type) {
            orthoCamera.left = window.innerWidth / -50;
            orthoCamera.right = window.innerWidth / 50;
            orthoCamera.top = window.innerHeight / 50;
            orthoCamera.bottom = window.innerHeight / -50;
            orthoCamera.position.set(0, 50, 0);
            orthoCamera.lookAt(scene.position);
            orthoCamera.updateProjectionMatrix();

            document.getElementById('itemModal').style.display = 'none';
            gameState = 'placing';
            infoElement.innerText = 'Разместите объект. ПКМ/Палец - перемещение, Колесо/Щипок - зум.';
            let geometry;
            if (type === 'cube') geometry = new THREE.BoxGeometry(1, 1, 1);
            else if (type === 'sphere') geometry = new THREE.SphereGeometry(0.7, 32, 32);
            else if (type === 'cone') geometry = new THREE.ConeGeometry(0.7, 1.5, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, transparent: true, opacity: 0.6 });
            previewObject = new THREE.Mesh(geometry, material);
            previewObject.position.y = 0.5;
            scene.add(previewObject);
        }

        function placeObject() {
            if (gameState !== 'placing' || !previewObject) return;
            const finalMaterial = previewObject.material.clone();
            finalMaterial.opacity = 1;
            finalMaterial.transparent = false;
            const finalObject = new THREE.Mesh(previewObject.geometry, finalMaterial);
            finalObject.position.copy(previewObject.position);
            scene.add(finalObject);
            exitPlacingMode();
        }
        
        function exitPlacingMode() {
            if (previewObject) {
                scene.remove(previewObject);
                previewObject.geometry.dispose();
                previewObject.material.dispose();
                previewObject = null;
            }
            gameState = 'playing';
            infoElement.innerText = isTouchDevice ? "Используйте джойстик и тач для управления" : 'Используйте WASD для передвижения.';
        }

        // === СЛУШАТЕЛИ СОБЫТИЙ ===
        function onPointerDown(event) {
            const target = event.target;
            if (target.closest && (target.closest('#joystick-zone') || target.closest('.modal-overlay'))) return;
            
            if (gameState === 'placing') {
                isPanning = true;
            } else {
                isDragging = true;
            }
            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        }

        function onPointerMove(event) {
            if (isTouchDevice) event.preventDefault();

            if (gameState === 'placing') {
                if (isPanning) {
                    const deltaX = event.clientX - previousPointerPosition.x;
                    const deltaY = event.clientY - previousPointerPosition.y;
                    const panSpeed = 1 / orthoCamera.zoom;
                    orthoCamera.position.x -= deltaX * panSpeed;
                    orthoCamera.position.z -= deltaY * panSpeed;
                }
                // Обновление предпросмотра объекта
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, orthoCamera);
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0 && previewObject) {
                    previewObject.position.copy(intersects[0].point);
                    previewObject.position.y = 0.5;
                }
            } else if (isDragging) {
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi -= deltaY * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            }
            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        }

        function onPointerUp() {
            isDragging = false;
            isPanning = false;
        }
        
        function onTouchStart(event) {
            const target = event.target;
            if (target.closest && (target.closest('#joystick-zone') || target.closest('.modal-overlay'))) return;
            
            if (event.touches.length === 2 && gameState === 'placing') {
                isPinching = true;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            } else if (event.touches.length === 1) {
                onPointerDown(event.touches[0]);
            }
        }

        function onTouchMove(event) {
            if (isPinching && event.touches.length === 2 && gameState === 'placing') {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                const zoomFactor = currentPinchDistance / initialPinchDistance;
                orthoCamera.zoom *= zoomFactor;
                orthoCamera.zoom = Math.max(0.5, Math.min(5, orthoCamera.zoom));
                orthoCamera.updateProjectionMatrix();
                initialPinchDistance = currentPinchDistance;
            } else if (event.touches.length === 1) {
                onPointerMove(event.touches[0]);
            }
        }

        function onTouchEnd(event) {
            if (event.touches.length < 2) isPinching = false;
            if (event.touches.length < 1) onPointerUp();
        }

        function onWheel(event) {
            if (gameState !== 'placing') return;
            event.preventDefault();
            const zoomSpeed = 0.1;
            const zoomAmount = event.deltaY > 0 ? 1 - zoomSpeed : 1 + zoomSpeed;
            orthoCamera.zoom *= zoomAmount;
            orthoCamera.zoom = Math.max(0.5, Math.min(5, orthoCamera.zoom));
            orthoCamera.updateProjectionMatrix();
        }

        renderer.domElement.addEventListener('mousedown', onPointerDown);
        renderer.domElement.addEventListener('mousemove', onPointerMove);
        renderer.domElement.addEventListener('mouseup', onPointerUp);
        renderer.domElement.addEventListener('mouseleave', onPointerUp);
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());
        
        renderer.domElement.addEventListener('click', (event) => {
            if (gameState === 'placing' && !isPanning && !isPinching) {
                placeObject();
            }
        });

        document.addEventListener('keydown', (event) => {
            if (gameState === 'playing' || gameState === 'placing') keysPressed[event.code] = true;
            if (event.code === 'Escape' && gameState === 'placing') exitPlacingMode();
        });
        document.addEventListener('keyup', (event) => keysPressed[event.code] = false);
        
        focusOverlay.addEventListener('click', () => {
            gameState = 'playing';
            focusOverlay.style.display = 'none';
        }, { once: true });

        window.addEventListener('blur', () => {
            if (['playing', 'placing', 'modal'].includes(gameState)) {
                gameState = 'paused';
                keysPressed = {};
                if(joystick) joystickVector.set(0,0);
                infoElement.innerText = 'Игра на паузе';
            }
        });
        window.addEventListener('focus', () => {
            if (gameState === 'paused') {
                gameState = 'playing';
                infoElement.innerText = isTouchDevice ? "Используйте джойстик и тач для управления" : 'Используйте WASD для передвижения.';
            }
        });

        document.getElementById('addCubeBtn').addEventListener('click', () => startPlacingMode('cube'));
        document.getElementById('addSphereBtn').addEventListener('click', () => startPlacingMode('sphere'));
        document.getElementById('addConeBtn').addEventListener('click', () => startPlacingMode('cone'));
        document.getElementById('cancelBtn').addEventListener('click', closeModal);
        document.getElementById('itemModal').addEventListener('click', (event) => { if (event.target.id === 'itemModal') closeModal(); });
        
        // === ИГРОВОЙ ЦИКЛ ===
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (['playing', 'placing', 'modal'].includes(gameState)) gameTime += delta;

            const cycleTime = gameTime % TOTAL_CYCLE_DURATION;
            const isCurrentlyNight = cycleTime > DAY_DURATION;
            const transitionProgress = Math.sin((gameTime / TOTAL_CYCLE_DURATION) * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.5;
            renderer.setClearColor(dayColor.clone().lerp(nightColor, transitionProgress));
            ambientLight.intensity = THREE.MathUtils.lerp(1.0, 0.1, transitionProgress);
            directionalLight.intensity = THREE.MathUtils.lerp(1.5, 0.0, transitionProgress);

            if (isCurrentlyNight) {
                if (!isNight) { isNight = true; nightCubes.forEach(cube => cube.visible = true); }
                timerLabel.innerText = 'До рассвета: ';
                timerValue.innerText = formatTime(TOTAL_CYCLE_DURATION - cycleTime);
            } else {
                if (isNight) { isNight = false; nightCubes.forEach(cube => cube.visible = false); }
                timerLabel.innerText = 'До заката: ';
                timerValue.innerText = formatTime(DAY_DURATION - cycleTime);
            }

            if (gameState === 'playing') {
                const cameraDirection = new THREE.Vector3();
                mainCamera.getWorldDirection(cameraDirection);
                const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                const right = new THREE.Vector3().crossVectors(forward, mainCamera.up);
                
                const moveDirection = new THREE.Vector3();
                if (isTouchDevice) {
                    moveDirection.add(forward.clone().multiplyScalar(joystickVector.y));
                    moveDirection.add(right.clone().multiplyScalar(joystickVector.x));
                } else {
                    if (keysPressed['KeyW']) moveDirection.add(forward);
                    if (keysPressed['KeyS']) moveDirection.sub(forward);
                    if (keysPressed['KeyA']) moveDirection.sub(right);
                    if (keysPressed['KeyD']) moveDirection.add(right);
                }
                
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    player.position.add(moveDirection.multiplyScalar(moveSpeed * delta));
                }
                
                const mapBoundary = 24.5;
                player.position.x = Math.max(-mapBoundary, Math.min(mapBoundary, player.position.x));
                player.position.z = Math.max(-mapBoundary, Math.min(mapBoundary, player.position.z));
                checkCheckpoint();
            }
            
            if (gameState === 'placing') {
                renderer.render(scene, orthoCamera);
            } else {
                cameraTarget.copy(player.position);
                cameraTarget.y += 1.0;
                const cameraPosition = new THREE.Vector3().setFromSpherical(spherical);
                mainCamera.position.copy(cameraTarget).add(cameraPosition);
                mainCamera.lookAt(cameraTarget);
                renderer.render(scene, mainCamera);
            }
        }

        window.addEventListener('resize', () => {
            mainCamera.aspect = window.innerWidth / window.innerHeight;
            mainCamera.updateProjectionMatrix();
            orthoCamera.left = window.innerWidth / -50;
            orthoCamera.right = window.innerWidth / 50;
            orthoCamera.top = window.innerHeight / 50;
            orthoCamera.bottom = window.innerHeight / -50;
            orthoCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
